---
title: 魔法优惠券
date: 2020-07-28 22:15:51
tags: [implementation]
categories: ACM
mathjax: true
---
## 题目
在火星上有个魔法商店，提供魔法优惠券。每个优惠劵上印有一个整数面值K，表示若你在购买某商品时使用这张优惠劵，可以得到K倍该商品价值的回报！该商店还免费赠送一些有价值的商品，但是如果你在领取免费赠品的时候使用面值为正的优惠劵，则必须倒贴给商店K倍该商品价值的金额…… 但是不要紧，还有面值为负的优惠劵可以用！（真是神奇的火星）

例如，给定一组优惠劵，面值分别为`1、2、4、-1`；对应一组商品，价值为火星币`M$7、6、-2、-3`，其中负的价值表示该商品是免费赠品。我们可以将优惠劵3用在商品1上，得到`M$28`的回报；优惠劵2用在商品2上，得到`M$12`的回报；优惠劵4用在商品4上，得到`M$3`的回报。但是如果一不小心把优惠劵3用在商品4上，你必须倒贴给商店`M$12`。同样，当你一不小心把优惠劵4用在商品1上，你必须倒贴给商店`M$7`。

规定每张优惠券和每件商品都只能最多被使用一次，求你可以得到的最大回报。
<!-- more -->

### 输入格式
输入有两行。第一行首先给出优惠劵的个数`N`，随后给出`N`个优惠劵的整数面值。第二行首先给出商品的个数`M`，随后给出`M`个商品的整数价值。`N`和`M`在$[1, 10​^6]$之间，所有的数据大小不超过$2^{30}$，数字间以空格分隔。

### 输出格式
输出可以得到的最大回报。

### 输入样例
> 4 1 2 4 -1
> 4 7 6 -2 -3

### 输出样例
> 43

## 分析
首先我们想到的是让面值为正的魔法优惠券与价值为正商品配合使用，面值为负的魔法优惠券与价值为负商品配合使用，对于面值与价值异号的一对魔法优惠券与商品，不去使用，这样就能保证至少不用倒贴钱。至于如何得到最大的回报，我们不妨先考虑所有魔法优惠券的面值与所有商品的价值均为正数的情况。

假设有$m(m\ge2)$张魔法优惠券，记为$a_1, a_2, ..., a_m$与$m(m\ge2)$件商品，记为$b_1, b_2, ..., b_m$，将他们按非升序进行排列，猜想当它们按排列顺序两两结合使用时，能获得最大收益，证明如下：

当$m=2$时，有
$$a_1 \ge a_2 > 0$$
$$b_1 \ge b_2 > 0$$

则有
$$
\begin{split}
   (a_1 b_1 + a_2 b_2) - (a_1 b_2 + a_2 b_1)
&= a_1 (b_1 - b_2) + a_2 (b_2 - b_1) \\\\
&= (a_1-a_2) (b_1-b_2) \\\\
&\ge 0
\end{split}
$$

即
$$a_1 b_1 + a_2 b_2 \ge a_1 b_2 + a_2 b_1$$

假设当$n=m(m \ge 2)$时，对于
$$a_1 \ge a_2 \ge ... \ge a_m > 0$$
$$b_1 \ge b_2 \ge ... \ge b_m > 0$$

分别在两数列内任取一个数直至取尽所有数，其乘积的和有最大值
$$a_1 b_1 + a_2 b_2 + ... + a_m  b_m$$

则当$n = m + 1(m \ge 2)$时，对于
$$a_1 \ge a_2 \ge ... \ge a_m \ge a_{m+1} >0$$
$$b_1 \ge b_2 \ge ... \ge b_m \ge b_{m+1} >0$$

由于找不到一个数$k(1 \le k \le m)$，使得$a_k b_{m+1} + a_{m+1} b_k > a_k b_k + a_{m+1} b_{m+1}$成立. 因此，当$n=m(m \ge 2)$时，有最大值
$$a_1 b_1 + a_2 b_2 + ... + a_m  b_m + a_{m + 1} b_{m + 1}$$

综上所述，对于数列
$$a_1 \ge a_2 \ge ... \ge a_n > 0 (n \ge 2)$$
$$b_1 \ge b_2 \ge ... \ge b_n > 0 (n \ge 2)$$
分别在两数列内任取一个数直至取尽所有数，其乘积的和有最大值
$$a_1 b_1 + a_2 b_2 + ... + a_n  b_n$$

同理，对于序列
$$0 > a_1 \ge a_2 \ge ... \ge a_n (n \ge 2)$$
$$0 > b_1 \ge b_2 \ge ... \ge b_n (n \ge 2)$$
分别在两数列内任取一个数直至取尽所有数，其乘积的和有最大值
$$a_n b_n + a_{n - 1} b_{n - 1} + ... + a_1 b_1$$

因此，我们只需将所有的魔法优惠券的面值和商品的价值按非升序（或是非降序）进行排序，对于同号的部分两两结合使用即可. 以输入样例为例，将魔法优惠券的面值按非升序进行排序，得`4, 2, 1, -1`，将商品的价值按非升序进行排序，得`7, 6, -2, -3`. 我们将4与7、2与6、-1与-3进行匹配并一起使用，可得最大收益43.

## 代码
```cpp
#include <iostream>
#include <algorithm>
using namespace std;

int num1[1000005], num2[1000005];
unsigned long long ans;

int main() {
    int N;
    cin >> N;

    for (int i = 0; i < N; i++)
        cin >> num1[i];

    int M;
    cin >> M;

    for (int i = 0; i < M; i++)
        cin >> num2[i];

    sort(num1, num1 + N);
    sort(num2, num2 + M);

    for (int i = 0, j = 0; i < N && j < M; i++, j++)
        if (num1[i] < 0 && num2[j] < 0)
            ans += num1[i] * num2[j];
        else
            break;

    for (int i = N - 1, j = M - 1; i >= 0 && j >= 0; i--, j--)
        if (num1[i] > 0 && num2[j] > 0)
            ans += num1[i] * num2[j];
        else
            break;

    cout << ans << endl;

    return 0;
}
```