{"pages":[{"title":"","text":"google-site-verification: google50ea925da7f8464f.html","link":"/google50ea925da7f8464f.html"},{"title":"关于","text":"@InFaNg 大二学生，坐标杭州，计算机科学与技术专业 E-Mail: helloinfang (at) gmail.com GitHub: @InFaNg","link":"/about/index.html"}],"posts":[{"title":"AtCoder Beginner Contest 192: D - Base n","text":"题目链接 D - Base n 思路 首先考虑特殊情况，即字符串$X$的长度为$1$时，若将$X$看作是$n$($n \\geq d + 1$)进制下的数，则$X$只有一种可能的取值，即十进制下的$X$本身，即在这种情况下，我们进行特判即可。 当字符串$len(X) \\geq 2$时，由于题目限制了$X$不含前导0，我们不难得出对于每一个不同的进制$n$($n \\geq d + 1$)，$X$都有一个不同的取值与之对应。因此我们需要$n = d + 1$开始判断，每次令$n := n + 1$，直到找到一种进制$n$，使得在$n$进制下有$X \\gt M$成立，此时停止迭代。然而在极端条件下，例如当$X = 10$，$M = 10^{18}$时，$n$要从$n = 2$开始，直到$n = 10^{18} + 1$才停止迭代，显然会超时。于是我们考虑二分：二分的左边界为d + 1，右边界为$10_18$，在这一范围内寻找符合题意的$n$的最大值。 不过这么做，新的问题又出现了。考虑极端情况，$X$的值为$60$个$9$，$n = 10_18$，此时我们将$X$转换为十进制下的值时肯定会出现溢出的问题。一种思路是使用Python，避免溢出问题。还有一种巧妙的方法：由于$M$的取值范围是$1 \\leq M \\leq 10^{18}$，我们可以使用C++中的__int128_t来进行运算，虽然__int128_t也无法存储上述极端情况下这么大的数字，不过我们可以运算到一半，发现它的值比$M$的值大时，退出即可。 代码 C++代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;string x;ll m;bool check(ll base) { __int128_t res = 0; for (const auto &amp;ch : x) { res = res * base + ch - '0'; if (res &gt; m) return false; } return true;}void solve() { cin &gt;&gt; x &gt;&gt; m; int d = 0; for (const auto &amp;ch : x) d = max(d, ch - '0'); if (x.size() == 1) { if (d &lt;= m) cout &lt;&lt; 1; else cout &lt;&lt; 0; return; } ll l = d + 1, r = ll(1e18) + 1; while (l &lt; r) { ll mid = (l + r) / 2; if (check(mid)) l = mid + 1; else r = mid; } cout &lt;&lt; l - 1 - d;}int main() { solve(); return 0;} Python代码 123456789101112131415161718192021222324252627282930313233x = input()m = int(input())def calc(n_base): res = 0 for e in x: res *= n_base res += int(e) return resd = -1for e in x: d = max(d, int(e))if len(x) == 1: if d &lt;= m: print(1) else: print(0)else: l, r = d + 1, int(1e18) + 1 while l &lt; r: mid = int((l + r) / 2) if (calc(mid) &lt;= m): l = mid + 1 else: r = mid print(l - 1 - d)","link":"/2021/02/21/abc-192-d/"},{"title":"AtCoder Beginner Contest 189: D - Logical Expression","text":"题目链接 D - Logical Expression 思路 如果$S_i$为AND，此时对于$y_i=y_{i-1} \\land x_i$，要使得其值为True的充要条件为$y_{i-1}$为True且$x_i$为True。如果$S_i$为OR，此时对于$y_i=y_{i-1} \\lor x_i$，要使得其值为True的充要条件为$y_{i-1}$与$x_i$至少有一个为True。 因此以$dp_i$表示能够使$y_i$为True的变量组$(x_0,\\ldots,x_i)$的数量，我们可以写出状态转移表达式： $$ dp_i = \\ \\begin{cases} 1, &amp; i = 0 \\\\ dp_{i - 1} &amp; \\text{if $S_i$ is AND} \\\\ dp_{i - 1} + 2^i &amp; \\text{if $S_i$ is OR} \\\\ \\end{cases} $$ 上面对于$S_i$为OR的讨论中，$dp_{i - 1}$对应$x_i$为False且$y_{i-1}$为True的情况，而$2^i$对应了$x_i$为True，$y_{i-1}$为True的共$2^i - 1$种情况以及$x_i$为True，$y_{i-1}$为False的$1$种情况，其和为$2^i$。合起来恰好等价于$y_{i-1}$与$x_i$至少有一个为True。 代码 12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt;using namespace std;int n;vector&lt;string&gt; v(65);vector&lt;long long&gt; dp(65, 1LL);void solve() { cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; v[i]; for (int i = 1; i &lt;= n; i++) { if (v[i] == &quot;AND&quot;) dp[i] = dp[i - 1]; else dp[i] = dp[i - 1] + (1LL &lt;&lt; i); } cout &lt;&lt; dp[n] &lt;&lt; endl;}int main() { solve(); return 0;}","link":"/2021/01/31/abc189-d/"},{"title":"AtCoder Beginner Contest 189: E - Rotate and Flip","text":"题目链接 E - Rotate and Flip 思路 如果将原坐标表示为$(x, y)$，则下列操作所起到的作用分别为： 顺时针旋转$90$度：$(x, y) \\rightarrow (y, -x)$ 逆时针旋转$90$度：$(x, y) \\rightarrow (-y, x)$ 关于$x = p$对称：$(x, y) \\rightarrow (2p - x, y)$ 关于$y = p$对称：$(x, y) \\rightarrow (x, 2p - y)$ 然而，对于每次查询，其时间复杂度均为$\\scr{O}$($N$)，显然会超时。事实上我们可以使用变量来记录第$i$次操作后新坐标相对于最初的坐标的影响。观察上面四项操作，发现对于坐标的改变主要有以下五点： $x$与$y$互换 $x$改变符号 $y$改变符号 $x$加上$2p$ $y$加上$2p$ 因此，我们可以用五个数组来记录第$i$次操作后坐标的变化，分别名为swap, a, c, b, d。 若此时swap为假，则新坐标可表示为 $$(ax + b, cy + d)$$ 否则，新坐标为 $$(ay + b, cx + d)$$ 相应操作的具体变换步骤如下： 操作 $swap$对应变换 $a$对应变换 $c$对应变换 $b$对应变换 $d$对应变换 顺时针旋转$90$度 $swap_i = !swap_{i - 1}$ $a_i = a_{i - 1}$ $c_i = -c_{i - 1}$ $b_i = d_{i - 1}$ $d_i = -b_{i - 1}$ 逆时针旋转$90$度 $swap_i = !swap_{i - 1}$ $a_i = -a_{i - 1}$ $c_i = c_{i - 1}$ $b_i = -d_{i - 1}$ $d_i = b_{i - 1}$ 关于$x = p$对称 $swap_i = swap_{i - 1}$ $a_i = -a_{i - 1}$ $c_i = c_{i - 1}$ $b_i = 2 * p - b_{i - 1}$ $d_i = d_{i - 1}$ 关于$y = p$对称 $swap_i = swap_{i - 1}$ $a_i = a_{i - 1}$ $c_i = -c_{i - 1}$ $b_i = b_{i - 1}$ $d_i = 2 * p -d_{i - 1}$ 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;bits/stdc++.h&gt;using namespace std; void solve() { int n, m, q, op, p, x, y; cin &gt;&gt; n; vector&lt;pair&lt;int, int&gt;&gt; v(n + 1); for (int i = 1; i &lt;= n; i++) cin &gt;&gt; v[i].first &gt;&gt; v[i].second; cin &gt;&gt; m; vector&lt;bool&gt; swap(m + 1); vector&lt;int&gt; a(m + 1, 1), c(m + 1, 1); vector&lt;long long&gt; b(m + 1, 0LL), d(m + 1, 0LL); for (int i = 1; i &lt;= m; i++) { cin &gt;&gt; op; if (op == 3 || op == 4) cin &gt;&gt; p; if (op == 1 || op == 2) { swap[i] = !swap[i - 1]; a[i] = c[i - 1]; c[i] = a[i - 1]; b[i] = d[i - 1]; d[i] = b[i - 1]; if (op == 1) { c[i] *= -1; d[i] *= -1; } else { a[i] *= -1; b[i] *= -1; } } else { swap[i] = swap[i - 1]; a[i] = a[i - 1]; b[i] = b[i - 1]; c[i] = c[i - 1]; d[i] = d[i - 1]; if (op == 3) { a[i] *= -1; b[i] = 2 * p - b[i - 1]; } else { c[i] *= -1; d[i] = 2 * p - d[i - 1]; } } } cin &gt;&gt; q; while (q--) { cin &gt;&gt; x &gt;&gt; y; if (!swap[x]) printf(&quot;%lld %lld\\n&quot;, a[x] * v[y].first + b[x], c[x] * v[y].second + d[x]); else printf(&quot;%lld %lld\\n&quot;, a[x] * v[y].second + b[x], c[x] * v[y].first + d[x]); }} int main() { solve(); return 0;}","link":"/2021/01/31/abc189-e/"},{"title":"AtCoder Beginner Contest 189: F - Sugoroku2","text":"题目链接 F - Sugoroku2 思路 对于这一类求期望的题目，一般是使用概率DP加上倒推的方式。但这一道题目还有回到零点这一特殊的情况，需要一些额外的讨论，才能求得最终解。 首先我们不考虑根本走不到终点这一特殊情况，即假设能够走到终点的可能性始终存在。 假设从$i$走到终点所需要的步数为$f(i)$，则可由下式表示为： $$ f(i)= \\begin{cases} f(0) &amp; \\text{,$i$ $\\in$ {$A_i$, $\\ldots$, $A_K$},} \\\\ 0 &amp; , i \\ge N, \\\\ \\dfrac{1}{M}(f(i+1)+\\ldots+f(i+M))+1 &amp; \\text{,其他.} \\end{cases} $$ 设$f(0)$为$x$，可得等式 $$x = a * x + b$$ 即 $$x = \\frac{b}{1 - a}$$ 因此，从N - 1点到0点进行dp，期间维护当前点的前M项f(0)的系数和常数项系数即可。 最后对于不可能走到终点的情况进行特判。易证如果无法走到终点，$a$的系数为1。但由于double型运算精度问题，需使用abs(1 - a) &lt; 1e-6进行判断。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt;using namespace std;int n, m, k;double a, b;set&lt;int&gt; st;void solve() { cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; for (int i = 0, tmp; i &lt; k; i++) { cin &gt;&gt; tmp; st.insert(tmp); } vector&lt;pair&lt;double, double&gt;&gt; dp(n + 1); pair&lt;double, double&gt; sum; for (int i = n - 1; i &gt;= 0; i--) { if (st.count(i)) dp[i] = make_pair(1, 0); else { dp[i].first = sum.first / m; dp[i].second = sum.second / m + 1; } sum.first += dp[i].first; sum.second += dp[i].second; if (i + m &lt; n) { sum.first -= dp[i + m].first; sum.second -= dp[i + m].second; } } double a = dp[0].first; double b = dp[0].second; if (abs(1 - a) &lt; 1e-6) cout &lt;&lt; -1 &lt;&lt; endl; else cout &lt;&lt; setiosflags(ios::fixed) &lt;&lt; setprecision(4) &lt;&lt; b / (1 - a) &lt;&lt; endl;}int main() { solve(); return 0;}","link":"/2021/01/31/abc189-f/"},{"title":"AtCoder Beginner Contest 189 D,E,F题题解","text":"D - Logical Expression E - Rotate and Flip F - Sugoroku2","link":"/2021/02/01/abc189/"},{"title":"AtCoder Beginner Contest 190: C - Bowls and Dishes","text":"题目链接 C - Bowls and Dishes 题目大意 有编号为$N$的$1, 2, \\dots, N$个盘子，和$1, 2, \\dots, M$共$M$个条件。 当盘子$A_i$和$B_i$均有（一个或多个）球时，条件$i$被视为满足。 有$K$个编号为$1, 2, \\dots, K$的人，每个人都可以放一只球在盘子$C_i$或$D_i$上。 最多有多少种条件能得到满足？ 思路 不难发现$K$个人每个人有两种选择，所有可能的选择一共有$K!$种。对于题目给出的数据范围$1 ≤ K ≤ 16$，显然不会超时。可以选择位运算模拟每个人做出不同选择的情况，将$1$记为将球放在盘子$C_i$上，将$0$记为将球放在盘子$D_i$上。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt;using namespace std; void solve() { int n, m, k; cin &gt;&gt; n &gt;&gt; m; vector&lt;pair&lt;int, int&gt;&gt; v1(m); for (auto &amp;[x, y] : v1) cin &gt;&gt; x &gt;&gt; y; cin &gt;&gt; k; vector&lt;pair&lt;int, int&gt;&gt; v2(k); for (auto &amp;[x, y] : v2) cin &gt;&gt; x &gt;&gt; y; int ans = 0; for (int i = 0; i &lt; (1 &lt;&lt; k); i++) { vector&lt;bool&gt; tmp(n + 1); for (int j = 0; j &lt; k; j++) if (i &amp; (1 &lt;&lt; j)) tmp[v2[j].first] = true; else tmp[v2[j].second] = true; int cnt = 0; for (const auto &amp;[x, y] : v1) if (tmp[x] &amp;&amp; tmp[y]) cnt++; ans = max(ans, cnt); } cout &lt;&lt; ans;} int main() { solve(); return 0;}","link":"/2021/02/08/abc190-c/"},{"title":"AtCoder Beginner Contest 190: D - Staircase Sequences","text":"题目链接 D - Staircase Sequences 题目大意 输入一个$N$，问有几种公差为$1$且和为$N$的等差数列。 思路 对于一个正整数$N$，总可以将他表示成$a_{i-k} + \\dots + a_{i-1} + a_i + a_{i+1} + \\dots + a_{i+k}$($k \\ge 0$)的形式，即 $$ \\begin{align} N &amp; = a_{i-k} + \\dots + a_{i-1} + a_i + a_{i+1} + \\dots + a_{i+k} \\\\ &amp; = (2k + 1) * a_i \\\\ \\end{align} $$ 不难发现，每有一个$N$的奇数因子，就有一对$k$和$a_i$满足上述等式。 其中，若$a_{i-k} &gt; 0$，上式又可表示成 $$ \\begin{align} N &amp; = a_{i-k} + \\dots + a_{i-1} + a_i + a_{i+1} + \\dots + a_{i+k} \\\\ &amp; = -(a_{i-k}-1) + \\dots + 0 + (a_{i-k}-1) + a_{i-k} + \\dots + a_{i-1} + a_i + a_{i+1} + \\dots + a_{i+k} \\\\ \\end{align} $$ 反之，若$a_{i-k} \\le 0$，则可表示成 $$ \\begin{align} N &amp; = a_{i-k} + \\dots + a_{i-1} + a_i + a_{i+1} + \\dots + a_{i+k} \\\\ &amp; = (-a_{i-k}+1) + \\dots + a_{i-1} + a_i + a_{i+1} + \\dots + a_{i+k} \\\\ \\end{align} $$ 也就是说，对于每一个$N$的奇数因子，都有两个符合题意的等差数列与之对应，我们只需找出所有$N$的奇数因子，将其乘以$2$即为答案。 代码 1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long; void solve() { ll n; cin &gt;&gt; n; int ans = 0; for (ll i = 1; i * i &lt;= n; i++) if (n % i == 0) { if (i % 2 == 1) ans += 2; if (n / i % 2 == 1 &amp;&amp; n / i != i) ans += 2; } cout &lt;&lt; ans;} int main() { solve(); return 0;}","link":"/2021/02/08/abc190-d/"},{"title":"AtCoder Beginner Contest 190: E - Magical Ornament","text":"题目链接 E - Magical Ornament 思路 可以把题目给出的能够相邻的数字对看成图中的边，使用BFS分别找出$C_1, C_2, \\dots, C_K$它们两两连接所需要的最小代价。 接下来使用包含当前状态和最后一次操作的二维数组，从前往后进行动态规划。具体表达式如下： $$dp[bit][last] = min(dp[pre\\_bit][pre\\_last])$$ 其中bit包含$k$个二进制的0或1，表示当前已经选择了的数字，last表示上一次选择的数字。pre_bit为将bit中的任意一个1置为0，其余数组均不变的二进制数，pre_last则为pre_bit中任意一个值为1的位所表示的数字。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;bits/stdc++.h&gt;using namespace std;const int INF = int(1e6);void solve() { int n, m, k; cin &gt;&gt; n &gt;&gt; m; vector&lt;vector&lt;int&gt;&gt; adj(n + 1); for (int i = 0, a, b; i &lt; m; i++) { cin &gt;&gt; a &gt;&gt; b; adj[a].emplace_back(b); adj[b].emplace_back(a); } cin &gt;&gt; k; vector&lt;int&gt; arr(k + 1); for (int i = 1; i &lt;= k; i++) cin &gt;&gt; arr[i]; vector&lt;vector&lt;int&gt;&gt; bfs_result(k + 1, vector&lt;int&gt;(k + 1, INF)); for (int i = 1; i &lt;= k; i++) { vector&lt;int&gt; dist(n + 1, INF); dist[arr[i]] = 0; queue&lt;int&gt; q; q.push(arr[i]); while (!q.empty()) { int e = q.front(); q.pop(); for (const auto next : adj[e]) if (dist[next] &gt; dist[e] + 1) { dist[next] = dist[e] + 1; q.push(next); } } for (int j = 1; j &lt;= k; j++) bfs_result[i][j] = dist[arr[j]]; } vector&lt;vector&lt;int&gt;&gt; dp(1 &lt;&lt; k, vector&lt;int&gt;(k, INF)); for (int i = 0; i &lt; k; i++) dp[1 &lt;&lt; i][i] = 1; for (int bit = 1; bit &lt; (1 &lt;&lt; k); bit++) for (int i = 0; i &lt; k; i++) if (bit &amp; (1 &lt;&lt; i)) { int pre_bit = bit ^ (1 &lt;&lt; i); for (int j = 0; j &lt; k; j++) if (pre_bit &amp; (1 &lt;&lt; j)) dp[bit][i] = min(dp[bit][i], dp[pre_bit][j] + bfs_result[j + 1][i + 1]); } int ans = *min_element(dp.back().begin(), dp.back().end()); if (ans == INF) ans = -1; cout &lt;&lt; ans;}int main() { solve(); return 0;}","link":"/2021/02/08/abc190-e/"},{"title":"AtCoder Beginner Contest 190: F - Shift and Inversions","text":"题目链接 F - Shift and Inversions 思路 求数列逆序对的最佳方法为使用树状数组，其时间复杂度为$O(N \\log N)$。然而如果在本题中对每一次变化都去求一次逆序对，问题的时间复杂度会变成$O(N^2 \\log N)$，显然会超时。于是我们尝试找出每次变化的规律，尝试递推：当位于数列第一位的数字$a_i$被移动到数列尾部时，有$a_i + 1, a_i + 2, \\dots, N - 1$共$N - a_i - 1$个比$a_i$大的数到了它的前面，即产生了$N - a_i - 1$个逆序对。此外，在变化前有$0, 1, \\dots, a_i - 1$共$a_i$个比$a_i$小的数在它后面，构成了$a_i$个逆序对，现在这些逆序对随着这次移动被消除。 综上，每次移动的操作会产生$N - a_i - 1$个逆序对，消除$a_i$个逆序对。因此我们可以对输入的内容使用树状数组求逆序对，之后对其进行递推，时间复杂度为$O(N \\log N + N) = O(N \\log N)$。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long; int n;int num[int(3e5) + 5]; inline int lowbit(int x) { return x &amp; (-x);} void add(int x, int k) { for (; k &lt;= n; k += lowbit(k)) num[k] += x;} int sum(int x) { int ans = 0; for (; x; x -= lowbit(x)) ans += num[x]; return ans;} ll calc(const vector&lt;int&gt; &amp;v) { vector&lt;pair&lt;int, int&gt;&gt; tmp(n + 1); for (int i = 1; i &lt;= n; i++) { tmp[i].first = v[i]; tmp[i].second = i; } sort(tmp.begin(), tmp.end()); vector&lt;int&gt; rank(n + 1); for (int i = 1; i &lt;= n; i++) rank[tmp[i].second] = i; ll ans = 0; for (int i = n; i &gt;= 1; i--) { ans += sum(rank[i] - 1); add(1, rank[i]); } return ans;} void solve() { cin &gt;&gt; n; vector&lt;int&gt; v(n + 1); for (int i = 1; i &lt;= n; i++) cin &gt;&gt; v[i]; ll ans = calc(v); cout &lt;&lt; ans &lt;&lt; '\\n'; for (int i = 1; i &lt; n; i++) cout &lt;&lt; (ans = (ans + n - 2 * v[i] - 1)) &lt;&lt; '\\n';} int main() { solve(); return 0;}","link":"/2021/02/08/abc190-f/"},{"title":"AtCoder Beginner Contest 190 C,D,E,F题题解","text":"C - Bowls and Dishes D - Staircase Sequences E - Magical Ornament F - Shift and Inversions","link":"/2021/02/08/abc190/"},{"title":"布尔表达式","text":"题目 The objective of the program you are going to produce is to evaluate boolean expressions as the one shown next: Expression: ( V | V ) &amp; F &amp; ( F | V ) where V is for True, and F is for False. The expressions may include the following operators: ! for not , &amp; for and, | for or , the use of parenthesis for operations grouping is also allowed. To perform the evaluation of an expression, it will be considered the priority of the operators, the not having the highest, and the or the lowest. The program must yield V or F , as the result for each expression in the input file. Input The expressions are of a variable length, although will never exceed 100 symbols. Symbols may be separated by any number of spaces or no spaces at all, therefore, the total length of an expression, as a number of characters, is unknown. The number of expressions in the input file is variable and will never be greater than 20. Each expression is presented in a new line, as shown below. Output For each test expression, print &quot;Expression &quot; followed by its sequence number, &quot;: &quot;, and the resulting value of the corresponding test expression. Separate the output for consecutive test expressions with a new line. Use the same format as that shown in the sample output shown below. Sample Input ( V | V ) &amp; F &amp; ( F| V) !V | V &amp; V &amp; !F &amp; (F | V ) &amp; (!F | F | !V &amp; V) (F&amp;F|V|!V&amp;!F&amp;!(F|F&amp;V)) Sample Output Expression 1: F Expression 2: V Expression 3: V 题目链接 Boolean Expressions 分析 根据题意，在运算的优先级中：括号的优先级最大，其次为三种运算符，三种运算符（与、或、非）的优先级为 非 &gt; 与 &gt; 或。由于一个表达式中可能含有多个括号，括号内部又有可能含有括号，于是就可以想到使用递归来处理括号。 因此，我们的思路大致是：第一层处理或逻辑，第二场处理与逻辑，第三层处理非逻辑（注意：与表达式优先级恰好相反）。针对输入表达式，我们可以去除字符串中所有的空格，然后将其存入一个字符数组，并使用一个 int 型变量来记录当前所处理到的字符位置。 我们可以设计三个函数，分别对应处理以上的三个逻辑。对于或逻辑函数，只关心或逻辑，不关心其余部分，可以将或逻辑所连接的左右部分看作“最小单元”，具体细节交给与逻辑进行处理。同理，对于与逻辑函数，只关心与逻辑，不关心其余部分，可以将与逻辑所连接的左右两部分看作“最小单元”，具体细节交给非逻辑进行处理。而对于非逻辑函数，除了要根据非符号的个数判断是否为逆的同时，还要检测是否存在括号，如果存在括号，则将其交给或函数进行处理。 再来探讨有关三个逻辑函数设计的具体细节，对于或函数，只要其中的一个“最小单元”为真，则函数为真。而对于与函数，只有所有的“最小单元”均为真时，整个函数才为真。 了解完这些细节之后，就不难写出该题目的代码。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;vector&lt;char&gt; cmd;int cmdIndex = 0; // 当前处理到的字符的位置// 由题意可知，优先级中或大于与大于非，因此第一层判断或，第二层判断与，第三层判断非// 判断或逻辑的函数char expression_value() { char result = term_value(); while (true) { if (cmd[cmdIndex] == '|') { cmdIndex++; char next_result = term_value(); // 只要其中的一个“最小单元”为真，则函数为真 result = (result == 'V') ? 'V' : next_result; } else break; } return result;}// 判断与逻辑的函数char term_value() { char result = factor_value(); while (true) { if (cmd[cmdIndex] == '&amp;') { cmdIndex++; char next_result = factor_value(); // 只有所有的“最小单元”均为真时，整个函数才为真 result = (result == 'F') ? 'F' : next_result; } else break; } return result;}// 判断非逻辑的函数char factor_value() { char result; int count = 0; // 记录非逻辑的次数，用于之后的判断 while (cmd[cmdIndex] == '!') { count++; cmdIndex++; } if (cmd[cmdIndex] == '(') { cmdIndex++; result = expression_value(); cmdIndex++; // 顺便读取右括号 } else { result = cmd[cmdIndex]; cmdIndex++; } if (count % 2) return (result == 'V') ? 'F' : 'V'; return result;}int main() { string a; int t = 0; while (getline(cin, a)) { cmdIndex = 0; cmd.clear(); // 去掉输入的逻辑表达式中的空格，并将其存入名为 cmd 的 vector 中 for (int i = 0; i &lt; a.length(); i++) { if (a[i] != ' ') cmd.push_back(a[i]); } printf(&quot;Expression %d: %c\\n&quot;, ++t, expression_value()); } return 0;}","link":"/2020/07/11/boolean-expression/"},{"title":"Codeforces 1475A - Odd Divisor","text":"题目链接 Problem - 1475A - Codeforces 题目大意 给出一个整数$n$($2 \\le n \\le 10^{14}$)，判断$n$能否被一个大于1的奇数整除。 思路 首先考虑下算法的时间复杂度。如果对输入的每个整数进行质因子分解，如果能找到奇数的质因子则输出YES，反之输出NO，这么做的话其时间复杂度为$\\mathcal{O}(\\log n)$。显然对于题目中的测试用例数量$t$($1 \\le t \\le 10^4$)会出现超时。我们可以换下思路：怎么样的数只有偶数的质因子，且没有奇数的质因子。不难发现，如果一个数是$2$的$n$次幂，则符合上述条件，输出NO即可，反之输出YES。 接下来问题就转换成如何判断一个数是否是$2$的$n$次幂了。一个可行的思路是将所有的$x$($x = 2^n$且$2 \\le x \\le 2^{14}$)放入一个set中，之后判断set中是否存在输入的数字即可。不过还有一个更简单的思路：判断一个数以二进制表示时是否只有一个$1$，且这个数不为$1$本身。如果是，则这个数不存在奇数的质因子。由于题目规定了输入的$n \\ge 2$，因此无需对输入的数是否为$1$进行特判，直接根据其二进制表示时是否只有一个1来进行判断即可。 代码 12345678910111213141516171819202122#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;void solve() { ll n; cin &gt;&gt; n; if (__builtin_popcountll(n) == 1) cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl;}int main() { int t; cin &gt;&gt; t; while (t--) solve(); return 0;}","link":"/2021/01/27/codeforces-1475a/"},{"title":"Codeforces 1475B - New Year&#39;s Number","text":"题目链接 Problem - 1475B - Codeforces 题目大意 给出一个整数$n$($1 \\leq n \\leq 10^6$)，判断其是否能表示为$2020$和$2021$的和的形式。 思路 如果有$n = x \\cdot 2020 + y \\cdot 2021$，则必有$(x + y) \\cdot 2020 \\le n \\le (x + y) \\cdot 2021$。因此，我们可以根据是否有$\\lfloor \\frac{n}{2020} \\rfloor \\cdot 2020 \\le n \\le \\lfloor \\frac{n}{2020} \\rfloor \\cdot 2021$来判断其是否能由$2020$和$2021$的和来进行表示。 代码 12345678910111213141516171819#include &lt;bits/stdc++.h&gt;using namespace std;void solve() { int n; cin &gt;&gt; n; if (n &gt;= (n / 2020) * 2020 &amp;&amp; n &lt;= (n / 2020) * 2021) puts(&quot;YES&quot;); else puts(&quot;NO&quot;);}int main() { int t; cin &gt;&gt; t; while (t--) solve(); return 0;}","link":"/2021/01/27/codeforces-1475b/"},{"title":"Codeforces 1475C - Ball in Berland","text":"题目链接 Problem - 1475C - Codeforces 题目大意 毕业典礼上的舞会由若干对男女组成。已知共有$a$名男生和$b$名女生想要参加以及$k$对男女（不存在完全相同的两对）。要求在这几对男女中选出两对，使得没有人同时出现在两对之中，共有多少种取法？ 思路 可以先假设所有的取法都不冲突，一共有$C_k^i$种，再减去有一名男生同时出现在两对之中和有一名女生同时出现在两对之中的取法（即不符合题意的种类）。由于题目规定了给出的$k$对男女不存在完全相同的两对，因此我们无需担心重复减去某一对的问题。可以用两个map分别为mpa和mpb来记录第i个男生和第i个女生在给出的$k$对男女中出现的次数，然后遍历两个map，减去重复出现的取法即可得到答案。 使用数学公式可表示为： $$C_k^2 - \\sum_{i = 1}^a C_{mpa[i]}^2 - \\sum_{i = 1}^b C_{mpb[i]}^2$$ 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;const int MAXN = 2e5 + 5;ll cn2(ll x) { if (x == 2) return 1; else if (x &lt;= 1) return 0; return x * (x - 1) / 2;}void solve() { int a, b, k, ai[MAXN], bi[MAXN]; cin &gt;&gt; a &gt;&gt; b &gt;&gt; k; for (int i = 1; i &lt;= k; i++) cin &gt;&gt; ai[i]; for (int i = 1; i &lt;= k; i++) cin &gt;&gt; bi[i]; map&lt;int, int&gt; mpa, mpb; for (int i = 1; i &lt;= k; i++) { mpa[ai[i]]++; mpb[bi[i]]++; } ll ans = cn2(k); for (int i = 1; i &lt;= a; i++) ans -= cn2(mpa[i]); for (int i = 1; i &lt;= b; i++) ans -= cn2(mpb[i]); cout &lt;&lt; ans &lt;&lt; endl;}int main() { int t; cin &gt;&gt; t; while (t--) solve(); return 0;}","link":"/2021/01/27/codeforces-1475c/"},{"title":"Codeforces 1475D - Cleaning the Phone","text":"题目链接 Problem - 1475D - Codeforces 题目大意 Polycarp的手机里有$n$个应用，第$i$个应用占用$a_i$个单元的存储空间，具有$b_i$($b_i = 1$或$b_i = 2$)的舒适度，现在Polycarp需要释放至少$m$个单元的存储空间。求Polycarp最少需要损失多少的舒适度，或输出-1表示不存在能够释放至少$m$个单元的存储空间的方案。 思路 首先考虑贪心性质：将手机里的应用分为两类，分别是舒适度为$1$和舒适度为$2$的，并将它们所占用的存储空间按从大到小的顺序进行排序。之后删除应用时，优先删除排在前面（也就是占用存储空间较大）的应用。至于到底要删除多少个舒适度为$1$的应用和多少个舒适度为$2$的应用，如果直接根据哪个应用的$\\frac{存储空间}{舒适度}$更大就选择删除哪个的方法来进行选择是错误的。例如下面这组数据： 1235 102 3 2 3 21 2 1 2 1 如果优先选择删除$\\frac{存储空间}{舒适度}$更大的应用，显然$\\frac{2}{1} \\ge \\frac{3}{2} $，但是这么做释放了$2 + 2 + 2 + 3 + 3 = 11$个单元的存储空间，损失了$1 + 1 + 1 + 2 + 2 = 7$的舒适度，而事实我们可以选择删除$2$个占$3$个单元存储空间的应用和$2$个占$2$个单元存储空间的应用。这么做只需要损失$2 + 2 + 1 + 1 = 6$的舒适度，显然优于前者。因此，根据$\\frac{存储空间}{舒适度}$来进行判断是不合适的。 于是我们只好考虑暴力解法。直接遍历需要进行大量的求和运算，在这里我们可以先通过前缀和优化，来降低时间复杂度。之后通过二次遍历，找到舒适度损失最小的方案。 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;int n, m;vector&lt;int&gt; a(2e5 + 5), b(2e5 + 5);void solve() { cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; b[i]; vector&lt;int&gt; app1, app2; for (int i = 1; i &lt;= n; i++) if (b[i] == 1) app1.emplace_back(a[i]); else app2.emplace_back(a[i]); sort(app1.rbegin(), app1.rend()); sort(app2.rbegin(), app2.rend()); vector&lt;ll&gt; app1_prefix, app2_prefix; app1_prefix.emplace_back(0); app2_prefix.emplace_back(0); ll x = 0, y = 0; for (auto &amp;e : app1) { x += e; app1_prefix.emplace_back(x); } for (auto &amp;e : app2) { y += e; app2_prefix.emplace_back(y); } int ans = 2e6; for (int i = app1_prefix.size() - 1; i &gt;= 0; i--) { if (!app2_prefix.empty() &amp;&amp; app1_prefix[i] + app2_prefix.back() &lt; m) break; for (int j = app2_prefix.size() - 1; j &gt;= 0 &amp;&amp; app1_prefix[i] + app2_prefix[j] &gt;= m; j--) ans = min(ans, i + 2 * j); } if (ans == 2e6) cout &lt;&lt; -1 &lt;&lt; endl; else cout &lt;&lt; ans &lt;&lt; endl;}int main() { int t; cin &gt;&gt; t; while (t--) solve(); return 0;}","link":"/2021/01/27/codeforces-1475d/"},{"title":"Codeforces 1475E - Advertising Agency","text":"题目链接 Problem - 1475E - Codeforces 题目大意 给出两个整数$n$和$k$($1 \\le k \\le n \\le 1000$)，之后给出$n$个整数$a_1, a_2, \\ldots a_n$。选出其中的$k$个整数使它们的和最大。最多有几种选法(对$10^9 + 7$求模)？。 思路 问题的关键就在于假设大小为$x$的整数一共有$y$个，此时已经选择了$m$个数，还需要选择$k - m$个数，我们需要求的就是$C_y^{k - m}$。我们可以使用一张map来记录每个数字出现的次数，之后根据map的键从大到小进行遍历，如果此时map的值为小于$k$,就令$k := k - it-&gt;second$，否则就计算$C_k^{it-&gt;second}$并退出循环。如果循环结束了还没找到答案，就输出-1。 接下来的重点就是求$C_k^{it-&gt;second}$，由于该数值较大，且题目要求给出模意义下的答案，在这里需要使用乘法逆元、杨辉三角或利用等式$\\binom n k = \\binom {n-1} {k} + \\binom {n-1} {k-1}$结合动态规划的方法来计算组合数。这里我们选择乘法逆元的方法，如果对于乘法逆元还不熟悉，可以参考乘法逆元 - OI Wiki。如果使用快速幂法求乘法逆元，答案可表示为： $$C_k^{(it-&gt;second)} \\pmod {1e9 + 7} = \\prod_{i = 1}^{k - (it-&gt;second)} i^{1e9 + 7 - 2} \\pmod {1e9 + 7}$$ 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;const int MOD = 1e9 + 7;int n, k, tmp;int binpow(long long a, int b) { int ans = 1; a = a % MOD; for (; b; b &gt;&gt;= 1) { if (b &amp; 1) ans = (a * ans) % MOD; a = (a * a) % MOD; } return ans;}ll c(int n, int m) { if (n == m) return 1; ll ans = 1; for (int i = m + 1; i &lt;= n; i++) ans = ans * i % MOD; for (int i = 1; i &lt;= n - m; i++) ans = ans * binpow(i, MOD - 2) % MOD; return ans;}void solve() { map&lt;int, int&gt; mp; cin &gt;&gt; n &gt;&gt; k; for (int i = 0; i &lt; n; i++) { cin &gt;&gt; tmp; mp[tmp]++; } for (auto it = mp.rbegin(); it != mp.rend(); it++) { if (it-&gt;second &lt; k) k -= it-&gt;second; else { cout &lt;&lt; c(it-&gt;second, k) &lt;&lt; endl; return; } }}int main() { int t; cin &gt;&gt; t; while (t--) solve(); return 0;}","link":"/2021/01/27/codeforces-1475e/"},{"title":"Codeforces 1475F - Unusual Matrix","text":"题目链接 Problem - 1475F - Codeforces 题目大意 给出仅有$0$和$1$组成的矩阵$a$和矩阵$b$，它们的大小为$n \\times n$。可以对矩阵$a$的任意一行或任意一列做逻辑异或运算任意次（也可以是0次），问能否将矩阵$a$变换到矩阵$b$。 思路 我们的大致思路是：每一行或每一列至多进行一次操作，因为对同一行或同一列做两次以上的操作是没有意义的。此外，由于矩阵大小$1 \\leq n \\leq 1000$，我们可以尝试进行遍历所有行和列，看看能否找到可行的操作。 首先我们对矩阵$a$的第一行进行遍历：如果元素$a_{i, j} \\neq b_{i, j}$，则对其第$j$列进行操作。该操作完成后，我们确保了矩阵$a$的第一行与矩阵$b$一致，因此我们无需再对矩阵$a$中的任何一列进行操作，因为这会破坏它们第一行的一致性。同理，我们也无需对矩阵$a$中的第一行进行操作。接下来，我们直接从第二行开始遍历，即$2 \\leq i \\leq n$，如果对于$\\forall {1 \\leq j \\leq n}$，均有$a_{i, j} \\neq b_{i, j}$或$a_{i, j} = b_{i, j}$，则说明存在操作使得矩阵$a$变换为矩阵$b$，反之不存在。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;bits/stdc++.h&gt;using namespace std;int n;bool check(vector&lt;vector&lt;int&gt;&gt; a, const vector&lt;vector&lt;int&gt;&gt; &amp;b) { for (int j = 0; j &lt; n; j++) if (a[0][j] != b[0][j]) for (int i = 0; i &lt; n; i++) a[i][j] ^= 1; for (int i = 1; i &lt; n; i++) { bool flag = (a[i][0] == b[i][0]); for (int j = 1; j &lt; n; j++) if ((a[i][j] == b[i][j]) != flag) return false; } return true;}void solve() { cin &gt;&gt; n; vector&lt;vector&lt;int&gt;&gt; a, b; string s; for (int i = 0; i &lt; n; i++) { cin &gt;&gt; s; vector&lt;int&gt; tmp; for (auto &amp;e : s) tmp.emplace_back(e - '0'); a.emplace_back(tmp); } for (int i = 0; i &lt; n; i++) { cin &gt;&gt; s; vector&lt;int&gt; tmp; for (auto &amp;e : s) tmp.emplace_back(e - '0'); b.emplace_back(tmp); } if (check(a, b)) cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl;}int main() { int t; cin &gt;&gt; t; while (t--) solve(); return 0;}","link":"/2021/01/27/codeforces-1475f/"},{"title":"Codeforces 1475G - Strange Beauty","text":"题目链接 Problem - 1475G - Codeforces 题目大意 给出一串长度为$n$的数列，问至少需要删除几个元素，才能使得对于任意$a_i, a_j$($i \\ne j$)，均有$a_i$能被$a_j$整除或$a_j$能被$a_j$整除。 思路 从反面来思考问题：数列中最多有几个元素能够满足上述性质。这里使用动态规划，用dp[i]记录前$i$个元素中所能满足上述性质的元素个数。具体的dp表达式为($cnt(x)$表示值为$i$的元素个数)： $$dp(x) = cnt(x) + \\max \\limits_{y = 1, x mod y = 0}^{x-1} dp(y)$$ 代码 1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 2e5 + 5;void solve() { int n, tmp; vector&lt;int&gt; cnt(MAXN), dp(MAXN); cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) { cin &gt;&gt; tmp; cnt[tmp]++; } for (int i = 1; i &lt; MAXN; i++) { dp[i] += cnt[i]; for (int j = 2 * i; j &lt; MAXN; j += i) dp[j] = max(dp[j], dp[i]); } cout &lt;&lt; n - *max_element(dp.begin(), dp.end()) &lt;&lt; endl;}int main() { int t; cin &gt;&gt; t; while (t--) solve(); return 0;}","link":"/2021/01/27/codeforces-1475g/"},{"title":"Codeforces Round #697 (Div. 3) 题解","text":"A. Odd Divisor B. New Year’s Number C. Ball in Berland D. Cleaning the Phone E. Advertising Agency F. Unusual Matrix G. Strange Beauty","link":"/2021/01/27/codeforces-round-697/"},{"title":"Igor In the Museum","text":"本文将介绍 Codeforces 上一道图论的题目，并使用 Depth-First Search (DFS, 深度优先搜索) 算法进行解决. 题目 Igor is in the museum and he wants to see as many pictures as possible. Museum can be represented as a rectangular field of n × m cells. Each cell is either empty or impassable. Empty cells are marked with ‘.’, impassable cells are marked with ‘*’. Every two adjacent cells of different types (one empty and one impassable) are divided by a wall containing one picture. At the beginning Igor is in some empty cell. At every moment he can move to any empty cell that share a side with the current one. For several starting positions you should calculate the maximum number of pictures that Igor can see. Igor is able to see the picture only if he is in the cell adjacent to the wall with this picture. Igor have a lot of time, so he will examine every picture he can see. Input First line of the input contains three integers $n$, $m$ and $k (3 ≤ n, m ≤ 1000, 1 ≤ k ≤ min(n·m, 100 000))$ — the museum dimensions and the number of starting positions to process. Each of the next $n$ lines contains $m$ symbols ‘.’, ‘*’ — the description of the museum. It is guaranteed that all border cells are impassable, so Igor can’t go out from the museum. Each of the last $k$ lines contains two integers $x$ and $y (1 ≤ x ≤ n, 1 ≤ y ≤ m)$ — the row and the column of one of Igor’s starting positions respectively. Rows are numbered from top to bottom, columns — from left to right. It is guaranteed that all starting positions are empty cells. Output Print $k$ integers — the maximum number of pictures, that Igor can see if he starts in corresponding position. 题目链接 Problem - 598D - Codeforces 分析 最初我的想法很简单，只需判断对于给定的起始位置，其上下左右四个方向是墙、空地还是超出边界的情况. 如果是墙，则答案 + 1，如果是空地，就递归进行搜索，如果是超出了边界，那就什么也不做. 具体代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;const int dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1};int n, m, k, x, y, ans;char matrix[1005][1005];bool vis[1005][1005];void dfs(int x, int y) { vis[x][y] = true; for (int i = 0; i &lt; 4; i++) { int xx = x + dir[i][0]; int yy = y + dir[i][1]; if (vis[xx][yy] || matrix[xx][yy] == 0) continue; if (matrix[xx][yy] == '.') dfs(xx, yy); else ans++; }}int main() { cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) cin &gt;&gt; matrix[i][j]; for (int i = 0; i &lt; k; i++) { memset(vis, false, sizeof(vis)); ans = 0; cin &gt;&gt; x &gt;&gt; y; dfs(x, y); cout &lt;&lt; ans &lt;&lt; endl; } return 0;} 这么做好像也没有什么问题，但是在 Codeforces 的中会出现测试数据超时的情况，后来我又改用了 BFS 算法，结果也是超时. 看来，搜索部分的算法已经比较难再进行优化了，于是我们换一个思路，能否通过缓存搜索结果的方式来加快程序运行速度呢？显然是可以的. 我们可以将由墙围城的面积看作是一块封闭空间，题目中的 Igor 无论从封闭空间中的哪一块区域开始，他所能看到的画的数量都是相等的. 因此，我们很容易想到缓存每一块封闭空间内所能看到的画的数量. 这样，当我们查询一块封闭空间内已缓存的格子时，时间复杂度仅为 $\\Theta(1)$. 如下图所示，图中 * 代表该位置有墙，数字则代表从这里开始最多可以看到几幅画. 代码 最终 AC 的代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;cstdio&gt;char s[1005][1005];int v[1005][1005], ans[1000500], pos;const int dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1};void dfs(int x, int y) { v[x][y] = pos; for (int i = 0; i &lt; 4; i++) { int xx = x + dir[i][0]; int yy = y + dir[i][1]; if (v[xx][yy] || s[xx][yy] == 0) continue; if (s[xx][yy] == '.') dfs(xx, yy); else ans[pos]++; }}int main() { int n, m, k; scanf(&quot;%d %d %d&quot;, &amp;n, &amp;m, &amp;k); for (int i = 1; i &lt;= n; i++) scanf(&quot;%s&quot;, s[i] + 1); for (int i = 0; i &lt; k; i++) { int x, y; scanf(&quot;%d %d&quot;, &amp;x, &amp;y); if (!v[x][y]) { pos++; dfs(x, y); } printf(&quot;%d\\n&quot;, ans[v[x][y]]); } return 0;}","link":"/2020/08/20/igor-in-the-museum/"},{"title":"魔法优惠券","text":"题目 在火星上有个魔法商店，提供魔法优惠券。每个优惠劵上印有一个整数面值K，表示若你在购买某商品时使用这张优惠劵，可以得到K倍该商品价值的回报！该商店还免费赠送一些有价值的商品，但是如果你在领取免费赠品的时候使用面值为正的优惠劵，则必须倒贴给商店K倍该商品价值的金额…… 但是不要紧，还有面值为负的优惠劵可以用！（真是神奇的火星） 例如，给定一组优惠劵，面值分别为1、2、4、-1；对应一组商品，价值为火星币M$7、6、-2、-3，其中负的价值表示该商品是免费赠品。我们可以将优惠劵3用在商品1上，得到M$28的回报；优惠劵2用在商品2上，得到M$12的回报；优惠劵4用在商品4上，得到M$3的回报。但是如果一不小心把优惠劵3用在商品4上，你必须倒贴给商店M$12。同样，当你一不小心把优惠劵4用在商品1上，你必须倒贴给商店M$7。 规定每张优惠券和每件商品都只能最多被使用一次，求你可以得到的最大回报。 输入格式 输入有两行。第一行首先给出优惠劵的个数N，随后给出N个优惠劵的整数面值。第二行首先给出商品的个数M，随后给出M个商品的整数价值。N和M在$[1, 10​^6]$之间，所有的数据大小不超过$2^{30}$，数字间以空格分隔。 输出格式 输出可以得到的最大回报。 输入样例 4 1 2 4 -1 4 7 6 -2 -3 输出样例 43 分析 首先我们想到的是让面值为正的魔法优惠券与价值为正商品配合使用，面值为负的魔法优惠券与价值为负商品配合使用，对于面值与价值异号的一对魔法优惠券与商品，不去使用，这样就能保证至少不用倒贴钱。至于如何得到最大的回报，我们不妨先考虑所有魔法优惠券的面值与所有商品的价值均为正数的情况。 假设有$m(m\\ge2)$张魔法优惠券，记为$a_1, a_2, …, a_m$与$m(m\\ge2)$件商品，记为$b_1, b_2, …, b_m$，将他们按非升序进行排列，猜想当它们按排列顺序两两结合使用时，能获得最大收益，证明如下： 当$m=2$时，有 $$a_1 \\ge a_2 &gt; 0$$ $$b_1 \\ge b_2 &gt; 0$$ 则有 $$ \\begin{split} (a_1 b_1 + a_2 b_2) - (a_1 b_2 + a_2 b_1) &amp;= a_1 (b_1 - b_2) + a_2 (b_2 - b_1) \\\\ &amp;= (a_1-a_2) (b_1-b_2) \\\\ &amp;\\ge 0 \\end{split} $$ 即 $$a_1 b_1 + a_2 b_2 \\ge a_1 b_2 + a_2 b_1$$ 假设当$n=m(m \\ge 2)$时，对于 $$a_1 \\ge a_2 \\ge … \\ge a_m &gt; 0$$ $$b_1 \\ge b_2 \\ge … \\ge b_m &gt; 0$$ 分别在两数列内任取一个数直至取尽所有数，其乘积的和有最大值 $$a_1 b_1 + a_2 b_2 + … + a_m b_m$$ 则当$n = m + 1(m \\ge 2)$时，对于 $$a_1 \\ge a_2 \\ge … \\ge a_m \\ge a_{m+1} &gt;0$$ $$b_1 \\ge b_2 \\ge … \\ge b_m \\ge b_{m+1} &gt;0$$ 由于找不到一个数$k(1 \\le k \\le m)$，使得$a_k b_{m+1} + a_{m+1} b_k &gt; a_k b_k + a_{m+1} b_{m+1}$成立. 因此，当$n=m(m \\ge 2)$时，有最大值 $$a_1 b_1 + a_2 b_2 + … + a_m b_m + a_{m + 1} b_{m + 1}$$ 综上所述，对于数列 $$a_1 \\ge a_2 \\ge … \\ge a_n &gt; 0 (n \\ge 2)$$ $$b_1 \\ge b_2 \\ge … \\ge b_n &gt; 0 (n \\ge 2)$$ 分别在两数列内任取一个数直至取尽所有数，其乘积的和有最大值 $$a_1 b_1 + a_2 b_2 + … + a_n b_n$$ 同理，对于序列 $$0 &gt; a_1 \\ge a_2 \\ge … \\ge a_n (n \\ge 2)$$ $$0 &gt; b_1 \\ge b_2 \\ge … \\ge b_n (n \\ge 2)$$ 分别在两数列内任取一个数直至取尽所有数，其乘积的和有最大值 $$a_n b_n + a_{n - 1} b_{n - 1} + … + a_1 b_1$$ 因此，我们只需将所有的魔法优惠券的面值和商品的价值按非升序（或是非降序）进行排序，对于同号的部分两两结合使用即可. 以输入样例为例，将魔法优惠券的面值按非升序进行排序，得4, 2, 1, -1，将商品的价值按非升序进行排序，得7, 6, -2, -3. 我们将4与7、2与6、-1与-3进行匹配并一起使用，可得最大收益43. 代码 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int num1[1000005], num2[1000005];unsigned long long ans;int main() { int N; cin &gt;&gt; N; for (int i = 0; i &lt; N; i++) cin &gt;&gt; num1[i]; int M; cin &gt;&gt; M; for (int i = 0; i &lt; M; i++) cin &gt;&gt; num2[i]; sort(num1, num1 + N); sort(num2, num2 + M); for (int i = 0, j = 0; i &lt; N &amp;&amp; j &lt; M; i++, j++) if (num1[i] &lt; 0 &amp;&amp; num2[j] &lt; 0) ans += num1[i] * num2[j]; else break; for (int i = N - 1, j = M - 1; i &gt;= 0 &amp;&amp; j &gt;= 0; i--, j--) if (num1[i] &gt; 0 &amp;&amp; num2[j] &gt; 0) ans += num1[i] * num2[j]; else break; cout &lt;&lt; ans &lt;&lt; endl; return 0;}","link":"/2020/07/28/magic-coupon/"},{"title":"Painting the Fence","text":"本文将介绍 Codeforces 上一道暴力求解法的题目，并介绍如何使用前缀优化的方法来降低时间复杂度. 题目 Problem - 1132C - Codeforces 分析 如果单纯地只考虑暴力，我们可以使用一个数组来储存篱笆的状态，数组的下标对应篱笆的编号，数组的值对应共有几名油漆工可以粉刷数组下标对应的篱笆. 然后讨论去除所有去除任意两名不同的油漆工的情况，再对数组进行一次遍历，去除数组对应的值为零的篱笆，剩下的篱笆就是可以被粉刷的篱笆. 通过这种方法，虽然完成了题目所要求的问题，但其时间复杂度过高. 假设给出 $q$ 名油漆工，$n$ 个篱笆，其时间复杂度为 $$ T(q, n) = \\Theta(\\cfrac{q*(q-1)}{2}*n) $$ 上面算法最主要的问题是我们关心了数组的具体的值，事实上，我们只关心最终该篱笆是否能被粉刷，至于其到底是能由一名油漆工还是多名来负责完成无关紧要. 在对去除任意两名不同的油漆工的讨论里，需要用到两次遍历，我们可以在第一次遍历中维护一个数组，该数组负责记录那些只有一名油漆工负责的篱笆的数量，然后在第二次的遍历中，我们去除那些仅由一名油漆工负责且该油漆工未被雇佣的篱笆，求得的结果即为能够粉刷的篱笆数量. 对于这一记录只有一名油漆工负责的篱笆的数组，我们可以引入一个概念：前缀. 即从第一个篱笆到该数组下标的篱笆为止，该数组下标所对应的值记录了共有多少个篱笆仅由一名油漆工负责. 伪代码如下： 123456789101112131415161718for i = 1 to q - 1 // 第一次遍历油漆工 for j = left[i] to right[i] // left[i], right[i] 分别表示第 i 个油漆工粉刷篱笆的起始位置与终止位置 count[j]-- // count[i] 表示第 i 个篱笆能有几位油漆工负责 for j = 1 to n if count[j] == 1 pre[j] = pre[j - 1] + 1 // pre[j] 表示从第 1 个篱笆到第 j 个篱笆，共有多少个篱笆仅有一名油漆工负责 else pre[j] = pre[j - 1] if count[j] != 0 sum++ // 表示当前共有多少篱笆可被粉刷 for j = i + 1 to q // 第二次遍历油漆工 ans = max(ans, sum - (pre[right[j]] - pre[left[j] - 1])) for j = left[i] to right[i] count[j]++ // 恢复第一次遍历所去除的油漆工 其时间复杂度为： $$ \\begin{split} T(q, n) &amp;= \\Theta(\\sum_{i = 1}^{q - 1}({n + \\sum_{j = i + 1}^q{1}})) \\\\ &amp;= \\Theta((q - 1)*n + \\cfrac{q*(q-1)}{2}) \\end{split} $$ 代码 具体的 C++ 实现代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int n, q, sum, ans;int l[5005], r[5005], cnt[5005], pre[5005];int main() { cin &gt;&gt; n &gt;&gt; q; for (int i = 1; i &lt;= q; i++) { cin &gt;&gt; l[i] &gt;&gt; r[i]; for (int j = l[i]; j &lt;= r[i]; j++) cnt[j]++; } for (int i = 1; i &lt;= q - 1; i++) { for (int j = l[i]; j &lt;= r[i]; j++) cnt[j]--; sum = 0; for (int j = 1; j &lt;= n; j++) { pre[j] = cnt[j] == 1 ? pre[j - 1] + 1 : pre[j - 1]; if (cnt[j]) sum++; } for (int j = i + 1; j &lt;= q; j++) ans = max(ans, sum - pre[r[j]] + pre[l[j] - 1]); for (int j = l[i]; j &lt;= r[i]; j++) cnt[j]++; } cout &lt;&lt; ans &lt;&lt; endl; return 0;}","link":"/2020/08/20/painting-the-fence/"},{"title":"Pop Sequence","text":"题目 Given a stack which can keep M numbers at most. Push N numbers in the order of 1, 2, 3, …, N and pop randomly. You are supposed to tell if a given sequence of numbers is a possible pop sequence of the stack. For example, if M is 5 and N is 7, we can obtain 1, 2, 3, 4, 5, 6, 7 from the stack, but not 3, 2, 1, 7, 5, 6, 4. Input Specification Each input file contains one test case. For each case, the first line contains 3 numbers (all no more than 1000): M (the maximum capacity of the stack), N (the length of push sequence), and K (the number of pop sequences to be checked). Then K lines follow, each contains a pop sequence of N numbers. All the numbers in a line are separated by a space. Output Specification For each pop sequence, print in one line “YES” if it is indeed a possible pop sequence of the stack, or “NO” if not. Sample Input 5 7 5 1 2 3 4 5 6 7 3 2 1 7 5 6 4 7 6 5 4 3 2 1 5 6 4 3 7 2 1 1 7 6 5 4 3 2 Sample Output YES NO NO YES NO 题目截图 题目大意 给定栈的容量、入栈数字的数量和测试用例数，要求对于每个用例，判断出栈顺序是否有可能与所给要求一致。 其中，入栈必须按照数字从小到大的顺序，例如，只有当数字 1~6 均已入过栈后，数字 7 才能入栈。 例如，对于题目所给的第四个用例 5 6 4 3 7 2 1，我们可以这么做： 数字 1 入栈 数字 2 入栈 数字 3 入栈 数字 4 入栈 数字 5 入栈 数字 5 出栈 数字 6 入栈 数字 6 出栈 数字 4 出栈 数字 3 出栈 数字 7 入栈 数字 7 出栈 数字 2 出栈 数字 1 出栈 按照这个顺序，我们就可以得到所要求的数字序列 再如，对于第五个用例： 数字 1 入栈 数字 1 出栈 数字 2 入栈 数字 3 入栈 数字 4 入栈 数字 5 入栈 数字 6 入栈 此时，栈里面已经存在五个数字了，达到了所给的栈的最大容量 5，可是还是没能得到数字 7🤯，此时，我们可以认为不可能输出所要求的数字序列 分析 有了上面的思路，就不难用 C++ 去实现。我们可以自己去创建一个栈，当栈顶的数字不等于所要求的输出项时，就按照升序填入数字，当栈顶的数字等于所要求的输出项时，就将其弹出。当栈内存储数据超出所要求的栈的容量时，就认为题目所给的输出序列不可能完成。 然而，当栈内连一个数字也没有即当栈为空栈时，需要额外的判断才行而不能简单地使用 s.top() 命令，否则容易造成空指针错误。然而再加一层判断比较麻烦，我们可以在开始前，人为地往栈中加入一个数字（在下面的代码中，我加入的数字是0，当然，也可以是其他一个数例如 -1），然后在进行栈内元素个数的判断时，允许比题目所给要求的多一个即可。例如在我的代码中，while 循环的条件为 s.size() &lt;= M 而不是 s.size() &lt; M，即当栈内的元素个数已经为 M 时，仍允许往栈中再加入一个元素🧐 代码 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;stack&gt;using namespace std;int M, N, K;bool check(int a[]) { stack&lt;int&gt; s; int i = 0, num = 0; s.push(0); while(i &lt; N) { while (a[i] &gt; s.top() &amp;&amp; s.size() &lt;= M) s.push(++num); if (a[i++] == s.top()) s.pop(); else return false; } return 1;}int main() { cin &gt;&gt; M &gt;&gt; N &gt;&gt; K; int data[N]; while (K--) { for (int i = 0; i &lt; N; i++) cin &gt;&gt; data[i]; if (check(data)) cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl; } return 0;}","link":"/2020/07/17/pop-sequence/"},{"title":"2的幂次方表示","text":"本文将从一道递归的程序设计竞赛水题出发，大致说明递归的基本思路. 题目 任何一个正整数都可以用2的幂次方表示。例如： $$137 = 2^7 + 2^3 + 2^0$$ 同时约定方次用括号来表示，即ab可表示为a(b)。由此可知，137可表示为： $$2(7)+2(3)+2(0)$$ 进一步：$$7 = 2^2 + 2 + 2^0$$（$2^1$用2表示）。例如： $$3 = 2 + 2^0$$ 所以最后137可表示为： $$2(2(2)+2+2(0))+2(2+2(0))+2(0)$$ 又如： $$1315 = 2^{10} + 2^8 + 2^5 + 2 + 1$$ 所以1315最后可表示为： $$2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)$$ 输入 一个正整数n (n ≤ 20000) 输出 输出为一行，即符合约定的 n 的 0, 2 表示（在表示中不能有空格） 输入示例 137 输出示例 2(2(2)+2+2(0))+2(2+2(0))+2(0) 分析 由于最终输出数据的“最小单元”只有 2(0) 和 2，因此本题可使用递归的思路进行解决。递归边界即为 2(0) 和 2，对于大于或等于三的数，不断分解使其可以用 2(0) 和 2 来表示。在实际代码中，可对 n == 1 与 n == 2 的情况直接输出结果并跳出函数，对于 n &gt;= 3 的一般情况，则需进行更为细致的分析。 对于 n &gt;= 3 的情况，不难看出，可以用 2(n) 或 2 来表示小于等于它的最大的 2 次幂，如果找到的最大二次幂恰好能够表示该数，那么至此无需任何额外处理。如果不能恰好表示该数，则需加上它的余数，它的余数可用输出一个 + 字符并用递归来进行表示。 由此可以得到如下的伪代码: 123456789101112131415void print(整数 n) { if (n 为 1) { 输出 2(0) 并退出 } if (n 为 2) { 输出 2 并退出 } 输出小于等于n的最大的 2 次幂 if (n的最大的 2 次幂不能恰好表示n) { 输出 + 字符 进行递归 }} 其中，对于如何找到“小于等于所给整数的最大的 2 次幂”，可以使用 while 循环解决。下面给出完整的代码 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;cstdio&gt;void print(int n) { // 特殊情况 递归边界 if (n == 1) { printf(&quot;2(0)&quot;); return; } if (n == 2) { printf(&quot;2&quot;); return; } // 普遍情况 int i = 1, j = 0; while (i &lt;= n) { i *= 2; j++; } i /= 2; j--; if (j == 1) { printf(&quot;2&quot;); } else { printf(&quot;2(&quot;); print(j); printf(&quot;)&quot;); } if (n - i != 0) { putchar('+'); print(n - i); }}int main() { int n; while (scanf(&quot;%d&quot;, &amp;n) == 1) { print(n); putchar('\\n'); } return 0;}","link":"/2020/07/10/powers-of-2-to-represent-numbers/"},{"title":"Radar Installation","text":"题目 Assume the coasting is an infinite straight line. Land is in one side of coasting, sea in the other. Each small island is a point locating in the sea side. And any radar installation, locating on the coasting, can only cover d distance, so an island in the sea can be covered by a radius installation, if the distance between them is at most d. We use Cartesian coordinate system, defining the coasting is the x-axis. The sea side is above x-axis, and the land side below. Given the position of each island in the sea, and given the distance of the coverage of the radar installation, your task is to write a program to find the minimal number of radar installations to cover all the islands. Note that the position of an island is represented by its x-y coordinates. Input The input consists of several test cases. The first line of each case contains two integers n (1&lt;=n&lt;=1000) and d, where n is the number of islands in the sea and d is the distance of coverage of the radar installation. This is followed by n lines each containing two integers representing the coordinate of the position of each island. Then a blank line follows to separate the cases. The input is terminated by a line containing pair of zeros Output For each test case output one line consisting of the test case number followed by the minimal number of radar installations needed. “-1” installation means no solution for that case. Sample Input 3 2 1 2 -3 1 2 1 1 2 0 2 0 0 Sample Output Case 1: 2 Case 2: 1 题目截图 题目链接 1328 – Radar Installation 分析 对于如何使用尽可能少的雷达覆盖小岛的平面二维问题，我们的方法是求出每个小岛对应的雷达可以监测到的范围的区间（如果存在这样的区间的话），从而将二位问题转化为一维问题。其次对于所求得的所有区间，判断他们两两之间是否存在交集，如果没有交集则需要再加一个雷达。然而，在一般情况下区间是无序的，因此我们可以将它们排序，方便进行之后的区间的变量。 不妨将每个区间按照它们的末端进行升序排序。对于已经排好序的 n 个区间，我们记它们的起始位置分别为$a_1, a_2, …, a_n$，终止位置分别为$b_1, b_2, …, a_n$，如果表达式$a_i&gt;b_{i-1}$成立，则说明他们之间的交集不存在（或者说是空集），即我们需要再加一个雷达以进行检测。 代码 事实上，对于负无穷的定义，理论上使用-numeric_limits&lt;double&gt;::infinity()会更好，但很多OJ都不支持此用法，于是在本题的代码中，使用了double temp = -1000000000即定义一个足够小的数这种不太好的方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;using namespace std;pair&lt;double, double&gt; node[1005];bool cmp(pair&lt;double, double&gt; a, pair&lt;double, double&gt; b) { return a.second &lt; b.second;}int main() { int n, k = 0; double d; bool flag; while (scanf(&quot;%d %lf&quot;, &amp;n, &amp;d) == 2 &amp;&amp; (n || d)) { double x, y; flag = true; for (int i = 0; i &lt; n; i++) { scanf(&quot;%lf %lf&quot;, &amp;x, &amp;y); if (!flag) continue; if (y &gt; d) { flag = false; continue; } node[i].first = x - sqrt(d * d - y * y); node[i].second = x + sqrt(d * d - y * y); } printf(&quot;Case %d: &quot;, ++k); if (!flag) { printf(&quot;-1\\n&quot;); continue; } sort(node, node + n, cmp); int ans = 0; double temp = -1000000000; for (int i = 0; i &lt; n; i++) if (temp &lt; node[i].first) { ans++; temp = node[i].second; } printf(&quot;%d\\n&quot;, ans); } return 0;}","link":"/2020/07/13/radar-installation/"},{"title":"Root of AVL Tree","text":"本文将从一道要求求出 AVL树根结点的程序设计竞赛题目说起，介绍 AVL树的基本概念、平衡原理以及旋转操作，并给出相应的 C++ 代码实现. 如果对树的基本概念还不是很了解或了解不多，建议参考 树 (数据结构). 题目 An AVL tree is a self-balancing binary search tree. In an AVL tree, the heights of the two child subtrees of any node differ by at most one; if at any time they differ by more than one, rebalancing is done to restore this property. Figures 1-4 illustrate the rotation rules. Now given a sequence of insertions, you are supposed to tell the root of the resulting AVL tree. Input Specification Each input file contains one test case. For each case, the first line contains a positive integer N (≤20) which is the total number of keys to be inserted. Then N distinct integer keys are given in the next line. All the numbers in a line are separated by a space. Output Specification For each test case, print the root of the resulting AVL tree in one line. Sample Input 1: 5 88 70 61 96 120 Sample Output 1: 70 Sample Input 2: 7 88 70 61 96 120 90 65 Sample Output 2: 88 AVL树基本概念 对于一棵二叉搜索树 (binary search tree) 来说，如果它是一棵完全二叉树 (full binary tree)，那么对其进行查询、插入、删除等基本操作的最坏运行时间为$\\Theta(lg\\ n)$，但如果对于树上的每一个结点，如果最多只有一个结点，即构成最坏情况：整棵树事实上是一条线性链，那么对其进行基本操作的最坏运行时间则为$\\Theta(n)$. AVL树的名称取自它的两名发明者 Georgy Adelson-Velsky 与 Evgenii Landis的名字，并于 1962 年在一篇名为 “An algorithm for the organization of information” 的论文中首次公开. 与上图所示的普通的二叉搜索树 (binary search tree) 的区别就是 AVL树是一种自平衡二叉查找树，即 AVL树在插入或删除结点时，通过一对结点指针的调整保证了对于其中的任意一个结点，其左子树的高度与右子树的高度之差的绝对值不大于 1，以此保证树的平衡，做到了对其进行基本操作的最坏运行时间也为 $Θ(lg n)$. 然而，这么做的代价也有代价：需要对每个结点引入一个额外的属性来存储其高度，并需要额外的计算量来维护结点的高度. AVL树旋转方法 下面将介绍 AVL树的两种旋转方法：右旋和左旋. 右旋 首先来看第一种二叉树结构调整的方法：右旋： 如图所示，图中 A 结点的左子树树高为 2，右子树树高为 0（事实上，右子树是不存在的. 这里我们特别规定，将不存在的树其树高记为 0）. 我们可以将 B 结点设置为 A 与 α 的父结点. 这么做使得树在保证成为二叉搜索树 (binary search tree) 的同时，其左子树的高度与右子树的高度之差的绝对值不大于 1. 然而仅仅这么做，那还是有个问题：如果图中的 B 结点有一个右结点，那该怎么办呢？对于这种情况，二叉树的调整方法是：先将 B 的右子结点挂到 A 的左子结点上，再将 A 结点挂到 B 的右子结点上. 不难证明，这么做在没有破坏二叉搜索树 (binary search tree) 性质的同时，实现了向完全二叉树 (full binary tree) 的调整. 下面使用 C++ 代码来描述AVL的右旋调整操作： 12345678910AVLTree right_rotate(AVLTree A) { AVLTree B = A-&gt;Left; A-&gt;Left = B-&gt;Right; // 将 B 的右子结点挂到 A 的左子结点上 B-&gt;Right = A; // 将 A 结点挂到 B 的右子结点上 A-&gt;Height = Max(GetHeight(A-&gt;Left), GetHeight(A-&gt;Right)) + 1; B-&gt;Height = Max(GetHeight(B-&gt;Left), A-&gt;Height) + 1; return B;} 左旋 左旋操作与右旋操作的思路大致类似. 如下图所示，A 的左子树高为 0，其右子树高为2，两者树高之差的绝对值大于 1，因此我们将 B 设置为 A 与 α 的父结点. 对于 B 的左子结点 β，我们可将其挂在 A 的右子结点上. 下面使用 C++ 代码来描述AVL的左旋调整操作： 12345678910AVLTree left_rotate(AVLTree A) { AVLTree B = A-&gt;Right; A-&gt;Right = B-&gt;Left; // 将 A 的右子结点挂到 B 的左子结点上 B-&gt;Left = A; // 将 A 结点挂到 B 的左子结点上 A-&gt;Height = Max(GetHeight(A-&gt;Left), GetHeight(A-&gt;Right)) + 1; B-&gt;Height = Max(GetHeight(B-&gt;Right), A-&gt;Height) + 1; return B;} AVL树的重新平衡 (Rebalancing) 当向二叉树中插入或删除一个结点时，整个二叉树可能会出现临时的其中某个结点其左右子树高度差的绝对值大于 1 的情况. 这样的情况共有四种，它们分别是： RR 情况 (Right Right Situation) LL 情况 (Left Left Situation) RL 情况 (Right Left Situation) LR 情况 (Left Right Situation) RR 情况 (Right Right Situation) RR 情况 (Right Right Situation) 是指当其中的一个结点不平衡（即它的左子树与右子树树高之差的绝对值大于 1）时，破坏平衡的结点位于被破坏平衡结点的右子树的右子树上. 下图就比较清晰地说明了这一情况. 对于这种情况，我们只需对图中的 A 结点与 B 结点进行一次左旋调整即可. 即将 B 的左子结点挂到 A 的右子结点上，再将 A 挂到 B 的左子结点上. LL 情况 (Left Left Situation) LL 情况 (Left Left Situation) 与 RR 情况 (Right Right Situation) 类似，指当其中的一个结点不平衡（即它的左子树与右子树树高之差的绝对值大于 1）时，破坏平衡的结点位于被破坏平衡结点的左子树的左子树上. 因此，我们只需仿照上面相应的操作，对图中的 A 结点与 B 结点进行一次右旋调整即可. 即将 B 的右子结点挂到 A 的左子结点上，再将 A 挂到 B 的右子结点上. RL 情况 (Right Left Situation) RL 情况 (Right Left Situation) 如下图所示，其破坏平衡的结点位于被破坏平衡结点的右子树的左子树上. 对于这种情况的处理较上面介绍的两种方法又有不同，需要两次变换才能使得二叉数重新平衡 (rebalancing). 首先看第一次变换，我们将 B 与 C 两结点进行右旋，将 C 的右子结点挂到 B 的左子结点上，再将 B 挂到 C 的右子结点上. 再看第二次变换，我们将 A 与 C 两结点进行左旋，将 C 的左子结点挂到 A 的右子结点上，再将 A 挂到 C 的左子结点上. 至此，我们实现了 RL 情况 (Right Left Situation) 下二叉树的重新平衡 (rebalancing). LR 情况 (Left Right Situation) 再来看 LR 情况 (Left Right Situation)，其破坏平衡的结点位于被破坏平衡结点的左子树的右子树上，其思路大致与 RL 情况 (Right Left Situation) 下的思路一致，都是通过两次旋转的方法实现二叉树的重新平衡 (rebalancing). 第一次变换我们将 B 与 C 两节点左旋： 第二次变换我们将 A 与 C 两节点右旋： 思路 我们可以定义一个 insert 函数来实现向 AVL树中插入数据及重新平衡 (rebalancing)，该函数接受两个参数，分别是需要插入到的节点和需要插入的数据. 与普通的二叉搜索树类似，可使用递归的方式以实现将数据自动插入到树的最下一层. 需要特别注意的是，在 AVL树中，我们需要判断当前节点所构成的树是否存在需要重新平衡 (rebalancing) 的四种情况之一. 如果有，则需要根据前文所述的方法对其进行调整. 代码 了解上面的内容后，就不难写出该题目的 C++ 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef struct node *ptr_to_node;struct node { int data; ptr_to_node left; ptr_to_node right; int height;};int get_height(ptr_to_node N) { if (N == NULL) return 0; if (N-&gt;left == NULL &amp;&amp; N-&gt;right == NULL) return 1; if (N-&gt;right == NULL) return get_height(N-&gt;left) + 1; if (N-&gt;left == NULL) return get_height(N-&gt;right) + 1; return max(get_height(N-&gt;left), get_height(N-&gt;right)) + 1;}ptr_to_node right_rotate(ptr_to_node A) { ptr_to_node B = A-&gt;left; A-&gt;left = B-&gt;right; B-&gt;right = A; A-&gt;height = max(get_height(A-&gt;left), get_height(A-&gt;right)) + 1; B-&gt;height = max(get_height(B-&gt;left), A-&gt;height) + 1; return B;}ptr_to_node left_rotate(ptr_to_node A) { ptr_to_node B = A-&gt;right; A-&gt;right = B-&gt;left; B-&gt;left = A; A-&gt;height = max(get_height(A-&gt;left), get_height(A-&gt;right)) + 1; B-&gt;height = max(A-&gt;height, get_height(B-&gt;right)) + 1; return B;}ptr_to_node insert(ptr_to_node N, int X) { if (N == NULL) { N = (ptr_to_node)malloc(sizeof(node)); N-&gt;data = X; N-&gt;left = N-&gt;right = NULL; N-&gt;height = 0; } else if (X &lt; N-&gt;data) { N-&gt;left = insert(N-&gt;left, X); if (get_height(N-&gt;left) - get_height(N-&gt;right) == 2) if (X &lt; N-&gt;left-&gt;data) // LL情况 (Left Left Situation) N = right_rotate(N); else { // LR情况 (Left Right Situation) N-&gt;left = left_rotate(N-&gt;left); N = right_rotate(N); } } else if (X &gt; N-&gt;data) { N-&gt;right = insert(N-&gt;right, X); if (get_height(N-&gt;right) - get_height(N-&gt;left) == 2) if (X &gt; N-&gt;right-&gt;data) // RR情况 (Right Right Situation) N = left_rotate(N); else { // RL情况 (Right Left Situation) N-&gt;right = right_rotate(N-&gt;right); N = left_rotate(N); } } N-&gt;height = max(get_height(N-&gt;left), get_height(N-&gt;right)) + 1; return N;}int main() { int N; ptr_to_node T = NULL; cin &gt;&gt; N; while (N--) { int num; cin &gt;&gt; num; T = insert(T, num); } cout &lt;&lt; T-&gt;data &lt;&lt; endl; return 0;}","link":"/2020/08/05/root-of-avl-tree/"},{"title":"哈夫曼编码","text":"本文将从一道要求判断是否能用给定大小的位来表示给出字符串的题目说起，来介绍哈夫曼编码 (Huffman coding) 的来历、其算法的设计以及有关前缀码部分的证明，在文章的最后将给出这道题目的 C++ 代码实现. 题目 Problem Description Javac++ 一天在看计算机的书籍的时候，看到了一个有趣的东西！每一串字符都可以被编码成一些数字来储存信息，但是不同的编码方式得到的储存空间是不一样的！并且当储存空间大于一定的值的时候是不安全的！所以Javac++ 就想是否有一种方式是可以得到字符编码最小的空间值！显然这是可以的，因为书上有这一块内容–哈夫曼编码(Huffman coding)；一个字母的权值等于该字母在字符串中出现的频率。所以Javac++ 想让你帮忙，给你安全数值和一串字符串，并让你判断这个字符串是否是安全的？ Input 输入有多组case，首先是一个数字n表示有n组数据，然后每一组数据是有一个数值m(integer)，和一串字符串没有空格只有包含小写字母组成！ Output 如果字符串的编码值小于等于给定的值则输出yes，否则输出no。 Sample Input 2 12 helloworld 66 ithinkyoucandoit Sample Output no yes 题目链接 Safe Or Unsafe 哈夫曼编码 (Huffman coding) 的基本概念 首先我们来看一下什么是编码. 在计算机中，所有的文本都是以二进制数的形式来进行存储. 但是，对于一个给定的字符，到底应该对应哪个二进制数呢？对于这个问题，我们往往使用一套固定的编码系统，这套编码系统规定了字符与码字之间一一对应的关系. 常见的编码系统有 ASCII, Unicode 等，下面将以 ASCII 为例，大致说明编码的原理： 例如，我们想要在计算机中储存 gooooogle 这个英文单词，在 ASCII 中规定了字符与码字之间的关系： 字符 码字 e 01100101 g 01100111 l 01101100 o 01101111 因此，我们可以将 gooooogle 转为二进制的 ASCII 码 01100111_01101111_01101111_01101111_01101111_01101111_01100111_01101100_01100101（这里为浏览方便起见，在每个字符之间添加了下划线，在实际的存储过程中是没有这一下划线加以区分的）. ASCII 中的字符均使用 8 个码字进行表示，因此在读取时，计算机将每次读入八位码字并将其转为相应的字符，确保了存储与读取时数据的一致性. 可以看出，使用ASCII码的情况下计算机使用了 72 位的空间来存储 gooooogle 这个单词. 然而有没有更好的编码方法来存储这个单词，使其占用的空间更少呢？在这个例子中，总共只出现了 4 个不同的字符，因此在这种情况下我们无需使用 8 位码字来表示一个字符，事实上，用 2 位码字就够了. 因此我们可以自己定义一套如下的编码系统： 字符 码字 e 00 g 01 l 10 o 11 因此，gooooogle 的编码就变成了 01_11_11_11_11_11_01_10_00，这套编码只要用 18 位的空间就能存储 gooooogle 这一单词了. 上面的方法都是用了定长编码来储存字符，即使用固定长度的码字来表示某一字符. 例如在 ASCII 中，我们使用 8 位码字来表示字符，在后面我们自己的编码系统中，我们使用 2 位码字 来表示字符. 然而除了定长编码外，还有变长编码，即使用长度不同的码字来表示不同的字符，一般地，我们都对出现频次较高的字符使用较短长度的码字进行表示，对出现频次较低的字符使用较长长度的码字进行表示以节省空间. 例如，我们可以使用如下编码系统： 字符 码字 e 000 g 01 l 001 o 1 因此，我们可以使用编码 01_1_1_1_1_1_01_001_000 来表示单词 gooooogle，事实上，我们至少需要 15 位的空间来存储 gooooogle 这一单词. 上面所演示的对其进行编码的方法就是哈夫曼编码 (Huffman coding). 值得注意的是，要想使用变长编码清晰地、没有二义性地表示一个字符，我们必需保证使用的编码是一种前缀码，即对于编码系统中的每一个字符，都找不到另外一个字符，使得前者的码字是后者的前缀. 对于不是前缀码的编码系统，例如： 字符 码字 e 1 g 0 l 10 o 11 对于使用这套系统的编码，例如 1011，我们无法确定其表示的是 egee, lo, lee 还是 ego，前缀码保证了对于给定的一串编码，都有唯一确定的字符串与之对应. 如何构造哈夫曼编码 (Huffman coding) 构造哈夫曼编码，本质上就是构造长度最短的前缀码. 仍以单词 gooooogle 为例，我们首先统计每个字符出现的次数. 字符 出现次数 e 1 g 2 l 1 o 5 统计完后，我们将按字符出现次数构造一个最小优先队列，并对队列中字符出现次数最小的两个结点进行合并，合并操作一共进行 n - 1 次. 完成上面的操作后，我们就将相当于是创建了一棵二叉树，如下图所示： 建立完二叉树后，就不难得到字符所对应的码字：从根结点开始，自上而下地去寻找字符，其中 0 表示左子结点、1 表示右子结点. 例如，e 位于根结点的左子结点的左子结点的右子结点，那么它的码字就是 001. 由于在我们构造的二叉树中，字符都位于二叉树的叶子结点上，所以我们所构造的码字就是一种前缀码，证明如下： 我们用反证法来证明： 假设我们构造的码字不是一种前缀码，那么必然存在一个字符，它的码字为编码系统中另一个字符码字的前缀，在二叉树中，它就必然是另一个字符的父结点，即它在二叉树中的结点就不是叶子结点. 这一结论与命题相矛盾，故原命题成立. 题目分析 在上面的分析中我们不难得出规律：对于一个字符，其码字的长度等于该字符所对应的结点在二叉树中的深度. 然而，在这道题目中，我们根本不关心二叉树的数据结构，我们也无需建立二叉树的数据结构. 事实上，对于二叉树中的任意一个非根结点，其深度总等于其与其它结点的合并次数. 因此，我们可以在合并最小优先队列中的两个数值最小的结点时，就将它们的和加到答案中，并在最小优先队列中删去这两项，然后在最小优先队列中加入一个结点，该结点的值为删去的两个结点的数值之和. 伪代码描述如下： GET_LENGTH() 12345678910111213ans = 0while minimum_priority_queue.size() != 1 first = minimum_priority_queue.top() minimum_priority_queue.pop() second = minimum_priority_queue.top() minimum_priority_queue.pop() ans = ans + first + second minimum_priority_queue.insert(first + second)return ans 代码 C++ 实现的代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;cstring&gt;using namespace std;int n, m, ans, count[26];char s[1000];int main() { while (cin &gt;&gt; n) while (n--) { cin &gt;&gt; m &gt;&gt; s; memset(count, 0, sizeof(count)); for (int i = 0; i &lt; strlen(s); i++) count[s[i] - 'a']++; priority_queue&lt; int, vector&lt;int&gt;, greater&lt;int&gt; &gt; q; for (int i = 0; i &lt; 26; i++) q.push(count[i]); if (q.size() == 1) ans = strlen(s); else { ans = 0; while (q.size() != 1) { int a = q.top(); q.pop(); int b = q.top(); q.pop(); ans += (a + b); q.push(a + b); } } if (ans &gt; m) cout &lt;&lt; &quot;no&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;yes&quot; &lt;&lt; endl; } return 0;}","link":"/2020/08/10/safe-or-unsafe/"},{"title":"树的遍历","text":"题目 给定一棵二叉树的后序遍历和中序遍历，请你输出其层序遍历的序列。这里假设键值都是互不相等的正整数。 输入格式 输入第一行给出一个正整数 N（≤30），是二叉树中结点的个数。第二行给出其后序遍历序列。第三行给出其中序遍历序列。数字间以空格分隔。 输出格式 在一行中输出该树的层序遍历的序列。数字间以1个空格分隔，行首尾不得有多余空格。 输入样例 7 2 3 1 5 7 6 4 1 2 3 4 5 6 7 输出样例 4 1 6 3 5 7 2 分析 以题目给定输入样例为例，我们可以参考【数据结构】玩转二叉树的做法. 只不过在这道题中，我们需要根据后续遍历的最后一位确定树的根节点，然后在中序遍历中找到树的根节点. 位于树的左边的数即为树的左子节点所包含的数，树的右边的数即为树的右子节点所包含的数. 使用递归循环往复，直到左子节点、右子节点均不含子节点为止. 下面以图片形式给出了具体的过程 但是，我们真的需要定义一个结构体来储存树的每一个节点所对应的值、它的左子节点和它的右子节点吗？这么做是没有什么问题，但是还有更好的方法. 我们可以使用两个一维数组，分别用来存放左子节点和右子节点的信息，数组的下标用来表示父节点的值，数组的值对应父节点的左子节点或是右子节点. 例如，我们可以令 L[4] = 1 表示 4 的左子节点是 1，令 R[4] = 6 表示 4 的右子节点是 6. 这么一来，不仅省去了定义结构体，还使得空间复杂度从 $T(n) = O(3n)$ 降为 $T(n) = O(2n)$. 由于需要给出层序遍历序列，因此我们可使用广度优先搜索(BFS)输出答案. 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;using namespace std;const int maxn = 1005;int N;int mid[maxn], post[maxn];int L[maxn], R[maxn];int build(int begin1,int end1,int begin2,int end2) { if(begin1 &gt; end1 || begin2 &gt; end2) return 0; for(int i = begin1;i &lt;= end1;i++) { if(mid[i] == post[end2]) { L[post[end2]] = build(begin1, i - 1, begin2, begin2 + i - begin1 - 1); R[post[end2]] = build(i + 1, end1, begin2 + i - begin1, end2 - 1); break; } } return post[end2];} void bfs() { queue&lt;int&gt; q; q.push(post[N]); cout &lt;&lt; post[N]; while(!q.empty()) { int element = q.front(); q.pop(); if(L[element]) { cout &lt;&lt; &quot; &quot; &lt;&lt; L[element]; q.push(L[element]); } if(R[element]) { cout &lt;&lt; &quot; &quot; &lt;&lt; R[element]; q.push(R[element]); } }}int main(){ cin &gt;&gt; N; for(int i = 1;i &lt;= N;i++) cin &gt;&gt; post[i]; for(int i = 1;i &lt;= N;i++) cin &gt;&gt; mid[i]; build(1,N,1,N); bfs(); return 0;}","link":"/2020/07/27/tree-traversals/"},{"title":"使用 Visual Studio Code 的 Remote – WSL 插件进行开发","text":"原文写于 2020 年 2 月，内容可能较旧，且官方文档现已提供中文版本。建议参考这里 最近学习 C 语言，由于 MSVC 编译器对于 C 标准支持非常之差，又不想为了在笔记本上安装 Linux 系统来折腾一大堆的驱动问题，于是打算使用 Windows Subsystem for Linux (WSL)，用 Linux 下的 GCC 编译器进行编译。前几天尝试了一下 VSCode 下的 Remote – WSL 插件，配合 WSL 来使用可以说是非常方便 必要的准备工作 要想使用 Visual Studio Code 的 Remote – WSL 插件进行开发，首先需要确保已经做好以下准备工作： 已经在 Windows 下安装了 WSL。完整的教程可以在微软官方的这篇文章：适用于 Linux 的 Windows 子系统安装指南 (Windows 10) 在 Windows 下安装了 Visual Studio Code 编辑器（注意：不是在 WSL 系统安装，而是直接在 Windows 系统下） 在 Visual Studio Code 上安装 Remote - WSL 这一扩展。 配置开发环境 打开 WSL 命令行（可以直接点击开始菜单中的 WSL 系统图标，也可以在 cmd 中输入 wsl） 在命令行中打开开发目录，例如我的开发目录是 D:\\wsl_workspace，则在命令行中输入 cd \\mnt\\d\\wsl_workspace 以跳转到开发目录。在 WSL 中，硬盘统一挂载在\\mnt\\ 下，即 \\mnt\\ 后的目录名是硬盘盘符，例如打开 C 盘可使用命令 cd \\mnt\\c 在命令行中输入 code .，此时，Visual Studio Code 会拷贝在 WSL 下需要用到的文件。整个过程可能会需要一段时间，不过一般不会很长 一段时间之后，会自动打开一个新的 VS Code 窗口，你会看到一个 VS Code 运行在 WSL 所对应的工作目录的提示 此时，VS Code 仍在自动配置运行在 WSL 中的相关环境 VS Code 自动配置结束后，左下角会出现一个提示运行在 WSL 开发环境中的小标记。接下来只需在 WSL 中配置相关的开发环境如安装 GCC 后，就可以和往常一样进行相应的开发 至此，相关的开发环境配置已全部完成。你可以像往常一样进行编剧文件、调试等各种操作，只是现在这些操作都是在 WSL 下进行 如果想从 WSL 环境中重新回到 Windows 开发环境，只需在 VS Code 中按下F1 键，然后输入命令 Remote-WSL: Reopen Folder in Windows 即可 同理，如果想从 Windows 开发环境下跳转到 WSL 环境，也只需在 VS Code 中按下F1 键，然后输入命令 Remote-WSL: Reopen Folder in WSL 解决 Git 出现大量文件改动的问题 在 Windows中，行尾是两个个字符 \\r\\n，而在 Linux 中，行尾只有一个字符 \\n。由于两者对于行尾的处理方式不同，使用 Git 同步时 Git 可能会检测到大量的文件改动。不过我们可以通过禁用行尾转换来修复这一问题 我们可以在工作目录下创建一个名为 .gitattributes 的文件，文件中内容如下： 123* text=auto eol=lf*.{cmd,[cC][mM][dD]} text eol=crlf*.{bat,[bB][aA][tT]} text eol=crlf 关于扩展 配置完 WSL 开发环境后，VS Code 的扩展会被安装在本地端或是 WSL 端。一般来说，只有少数扩展如主题之类的会被安装在本地端，剩下的大多数都需要安装在 WSL 端。因此，我们还需对 VS Code 中的扩展进行相关操作 之前大量安装在本地的扩展会被切换到 “Disabled” 状态，需要我们将其安装在 WSL 端才可继续使用原有扩展 不过好在我们只需点击 Install on WSL 即可一键将原有扩展安装在 WSL 端 在 VS Code 中打开 WSL 终端 如果VS Code中打开了一个 WSL 下的文件，那么在 VS Code 中打开的终端都会自动在 WSL 下运行而不是在 Windows 下的 CMD 或是 PowerShell运行，很是方便 在 WSL 下进行调试 在 WSL 下进行程序的调试也无需进行额外配置，VS Code 会自动根据 launch.json 对 WSL 下运行的程序进行相关的调试 资料来源 本文大多数内容根据官方文档翻译而成，所参考的官方文档如下： Windows Subsystem for Linux Installation Guide for Windows 10 Developing in the Windows Subsystem for Linux with Visual Studio Code Supporting Remote Development and Visual Studio Online","link":"/2020/02/13/vscode-developing-in-wsl/"},{"title":"玩转二叉树","text":"题目 给定一棵二叉树的中序遍历和前序遍历，请你先将树做个镜面反转，再输出反转后的层序遍历的序列。所谓镜面反转，是指将所有非叶结点的左右孩子对换。这里假设键值都是互不相等的正整数。 输入格式 输入第一行给出一个正整数N（≤30），是二叉树中结点的个数。第二行给出其中序遍历序列。第三行给出其前序遍历序列。数字间以空格分隔。 输出格式 在一行中输出该树反转后的层序遍历的序列。数字间以1个空格分隔，行首尾不得有多余空格。 输入样例 7 1 2 3 4 5 6 7 4 1 3 2 6 5 7 输出样例 4 6 1 7 5 3 2 题目截图 分析 由前序序列的性质可知，前序序列的第一个数一定是当前二叉树的根节点. 例如，再输入样例中第一个数是 4，因此我们可知 4 是二叉树的根节点。之后再在中序遍历序列中找到 4，就可以知道 4 的左边有三个数，分别是 1、2、3，4 的右边同样有三个数分别是 5、6、7. 此外，我们还可以知道前三个数 1、2、3 按照中序排序序列的顺序为 1、3、2，后三个数5、6、7的中序排序序列顺序为6、5、7. 接下来，我们可以利用递归分别对根节点左侧的三个数与右侧的三个数建立二叉树. 下面以左侧的三个数为例，它们的前序遍历序列为 1、3、2，中序遍历序列为 1、2、3. 将这三个数看作完整的二叉树，则他们的根节点是 1，它的左子节点为空，右子节点有两个数. 再对右侧两个数分析，它们的根节点为 3，左子节点为 2，右子节点为空. 这里需要特别注意的是，前序遍历序列为 3、2，中序遍历序列为 2、3 的两个数，只有可能为一个是父节点，一个为左子节点或右子节点，而不可能两个都为子节点，即必有一个为父节点. 因此不难得出，前序遍历序列的第一个数 3 即为父节点，在中序遍历序列中，2 位于 3 的左边，即 2 为 3 的左子节点. 对右边的子二叉树做同样的分析，即可得出右侧的结构. 接下来，只需建立个队列，将二叉树的每个节点的数据装入队列即可。其中，由于题目要求反转，只需先装入右子节点，再装入左子节点即可. 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;int N, A[35], B[35];struct TreeNode { int data, left_child, right_child;} node[35];int node_index = 1;void create_tree(int index, int begin1, int end1, int begin2, int end2);void print();void create_tree(int index, int begin1, int end1, int begin2, int end2) { node[index].data = B[begin2]; int father_index; for (father_index = begin1; father_index &lt; end1; father_index++) if (A[father_index] == B[begin2]) break; int left_N = father_index - begin1, right_N = end1 - father_index - 1; if (left_N) { node[index].left_child = ++node_index; create_tree(node[index].left_child, begin1, father_index, begin2 + 1, begin2 + 1 + left_N); } if (right_N) { node[index].right_child = ++node_index; create_tree(node[index].right_child, father_index + 1, end1, begin2 + 1 + left_N, end2); }}void print() { int arr[35], n = 0; queue&lt;int&gt; q; q.push(1); while (q.size()) { int i = q.front(); if (i) { arr[n++] = node[i].data; q.push(node[i].right_child); q.push(node[i].left_child); } q.pop(); } cout &lt;&lt; arr[0]; for (int i = 1; i &lt; n; i++) cout &lt;&lt; &quot; &quot; &lt;&lt; arr[i];}int main() { cin &gt;&gt; N; for (int i = 0; i &lt; N; i++) cin &gt;&gt; A[i]; for (int i = 0; i &lt; N; i++) cin &gt;&gt; B[i]; create_tree(1, 0, N, 0, N); print(); return 0;}","link":"/2020/07/19/wan-zhuan-er-cha-shu/"}],"tags":[{"name":"binary search","slug":"binary-search","link":"/tags/binary-search/"},{"name":"math","slug":"math","link":"/tags/math/"},{"name":"dp","slug":"dp","link":"/tags/dp/"},{"name":"bitmasks","slug":"bitmasks","link":"/tags/bitmasks/"},{"name":"AtCoder Beginner Contest","slug":"AtCoder-Beginner-Contest","link":"/tags/AtCoder-Beginner-Contest/"},{"name":"number","slug":"number","link":"/tags/number/"},{"name":"graphs","slug":"graphs","link":"/tags/graphs/"},{"name":"constructive algorithms","slug":"constructive-algorithms","link":"/tags/constructive-algorithms/"},{"name":"sortings","slug":"sortings","link":"/tags/sortings/"},{"name":"递归","slug":"递归","link":"/tags/%E9%80%92%E5%BD%92/"},{"name":"implementation","slug":"implementation","link":"/tags/implementation/"},{"name":"number theory","slug":"number-theory","link":"/tags/number-theory/"},{"name":"brute force","slug":"brute-force","link":"/tags/brute-force/"},{"name":"combinatorics","slug":"combinatorics","link":"/tags/combinatorics/"},{"name":"dfs and similar","slug":"dfs-and-similar","link":"/tags/dfs-and-similar/"},{"name":"hashing","slug":"hashing","link":"/tags/hashing/"},{"name":"greedy","slug":"greedy","link":"/tags/greedy/"},{"name":"two pointers","slug":"two-pointers","link":"/tags/two-pointers/"},{"name":"theory","slug":"theory","link":"/tags/theory/"},{"name":"Codeforces Round","slug":"Codeforces-Round","link":"/tags/Codeforces-Round/"},{"name":"DFS","slug":"DFS","link":"/tags/DFS/"},{"name":"data structures","slug":"data-structures","link":"/tags/data-structures/"},{"name":"binary tree","slug":"binary-tree","link":"/tags/binary-tree/"},{"name":"AVL tree","slug":"AVL-tree","link":"/tags/AVL-tree/"},{"name":"Huffman coding","slug":"Huffman-coding","link":"/tags/Huffman-coding/"},{"name":"VS Code","slug":"VS-Code","link":"/tags/VS-Code/"},{"name":"WSL","slug":"WSL","link":"/tags/WSL/"}],"categories":[{"name":"ACM","slug":"ACM","link":"/categories/ACM/"},{"name":"技术向","slug":"技术向","link":"/categories/%E6%8A%80%E6%9C%AF%E5%90%91/"}]}